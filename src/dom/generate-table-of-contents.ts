import { nanoid } from 'nanoid/non-secure';
import { toInteger } from '../numbers/to-integer';
import { isString } from '../strings/is-string';
import { slugify } from '../strings/slugify';


/**
 * The shape of heading entries that are created by tools like the
 * Codex or EditorJS block content editors.
 */
export type TableOfContentsObjectSource = {
  type : 'heading';
  id?  : string;
  data : { content: string; level: number };
} | {
  type : 'header',
  id?  : string;
  data : { text: string; level: number },
} | {
  type    : 'header';
  id?     : string;
  attrs   : { level: number };
  content : { type: string; text?: string }[];
};

/**
 * Config for the {@link generateTableOfContents} method.
 */
export type GenerateTableOfContentsOptions = {
  minDepth : 1 | 2 | 3 | 4 | 5 | 6;
  maxDepth : 1 | 2 | 3 | 4 | 5 | 6;
  enabled  : boolean;
};

/**
 * TableOfContents objects carry hierarchical information about headings
 * and their associated subheadings. They can be used to generate nested
 * lists.
 */
export type TableOfContents = {
  level    : number;
  text     : string;
  slug     : string;
  parent   : TableOfContents | undefined;
  children : TableOfContents[];
};

/**
 * The sort of things that the {@link generateTableOfContents} utility can use
 * to create a TOC.
 */
export type TableOfContentsSource = string | HTMLElement | TableOfContentsObjectSource[];

/**
 * The return type of {@link generateTableOfContents}.
 */
export type GenerateTableOfContentsReturn<S extends TableOfContentsSource> = {
  tableOfContents : TableOfContents[];
  contentSource   : S;
}

/**
 * Given an HTML container that contains one or more header elements, an object
 * or array of objects like those generated by tools like EditorJS, or even a
 * plain string of HTML content, this method will return a hierarchical representation
 * of the headers in a manner suitable for generating a table of contents.
 */
export function generateTableOfContents<S extends TableOfContentsSource>(
  source: S,
  options?: Partial<GenerateTableOfContentsOptions>,
): GenerateTableOfContentsReturn<S> {
  const config: GenerateTableOfContentsOptions = { minDepth: 2, maxDepth: 3, enabled: true, ...options };

  if (!config.enabled) {
    return { tableOfContents: [], contentSource: source };
  }

  let headings = [] as HeadingInfo[];

  if (isString(source)) {
    headings = extractStringSourceHeadings(source);
  }
  else if (source instanceof HTMLElement) {
    headings = extractElementSourceHeadings(source);
  }
  else if (Array.isArray(source)) {
    headings = extractObjectSourceHeadings(source);
  }
  else {
    return { tableOfContents: [], contentSource: source };
  }

  const tableOfContents = [] as TableOfContents[];

  let contentSource = source;
  let previousEntry = undefined as undefined | TableOfContents;

  for (const heading of headings) {
    if (heading.level < config.minDepth || heading.level > config.maxDepth) {
      continue;
    }

    const currentEntry = {
      level    : heading.level,
      text     : heading.text,
      slug     : heading.slug,
      parent   : undefined,
      children : [],
    } as TableOfContents;


    if (previousEntry) {
      if (previousEntry.level === heading.level) {
        adoptChild(currentEntry, previousEntry.parent, tableOfContents);
      }
      else if (previousEntry.level < currentEntry.level) {
        adoptChild(currentEntry, previousEntry);
      }
      else if (previousEntry.level > currentEntry.level) {
        let ancestor = previousEntry.parent;

        do {
          ancestor = ancestor?.parent;
        } while ((ancestor?.level ?? 0) >= currentEntry.level);

        adoptChild(currentEntry, ancestor, tableOfContents);
      }
    }
    else {
      tableOfContents.push(currentEntry);
    }


    heading.slug = currentEntry.slug;

    contentSource = isString(source) && isString(contentSource)
      ? heading.apply(contentSource, contentSource.length - source.length)
      : heading.apply(contentSource);

    previousEntry = currentEntry;
  }

  return { tableOfContents, contentSource };
}


// **********************************
// Below here are internals
// **********************************


const HeaderRegex = /<[\s\n\r\t]*[Hh](?<level>\d)(?<attrs>.*?)>(?<content>.*?)<\/[Hh]\d>/gms;
const IdAttrRegex = /(?<preId>.*?)id[\s\n\r\t]*=[\s\n\r\t]*["'](?<id>.*?)["'](?<postId>.*?)/s;


type HeadingInfo = {
  level : number;
  text  : string;
  slug  : string;
  apply : <Source>(update: Source, offsetOrIndex?: number) => Source;
};


/**
 * Makes a best-effort attempt to extract heading tag information from
 * a string of HTML content.
 */
function extractStringSourceHeadings(source: string) {
  const results: HeadingInfo[] = [];

  let match: RegExpExecArray | null = null;

  do {
    match = HeaderRegex.exec(source);

    if (match?.groups) {
      const level = toInteger(match.groups.level);
      const text  = match.groups.content;
      const attrs = match.groups.attrs?.match(IdAttrRegex);
      const slug  = attrs?.groups?.id || (match.groups.content ? slugify(match.groups.content) : nanoid(10));

      const originalMatch = match[0];
      const startingIdx   = match.index;
      const preIdAttrs    = attrs?.groups?.preId ?? '';
      const postIdAttrs   = attrs?.groups?.postId ?? '';

      results.push({
        level,
        slug,
        text,
        apply(update, offset = 0) {
          const tagName    = `h${ this.level }`;
          const attributes =  [preIdAttrs, `id="${ this.slug }"`, postIdAttrs].filter(Boolean).join(' ').trim();
          const newTag     = `<${ tagName } ${ attributes }>${ this.text }</${ tagName }>`;

          return isString(update)
            ? update.substring(0, startingIdx + offset) + newTag + update.substring(startingIdx + offset + originalMatch.length) as typeof update
            : update;
        },
      });
    }
  } while (match);

  return results;
}


/**
 * Extracts heading info from an HTMLElement (e.x. a <div /> with a bunch of content inside).
 */
function extractElementSourceHeadings(source: HTMLElement) {
  const results: HeadingInfo[] = [];

  source.querySelectorAll<HTMLHeadingElement>('h1,h2,h3,h4,h5,h6').forEach((element) => {
    const level = toInteger(element.tagName.at(-1));
    const slug  = element.id || (element.textContent ? slugify(element.textContent) : nanoid(10));

    results.push({
      level,
      slug,
      text: element.textContent || '',
      apply(update) {
        element.id = this.slug;
        return update;
      },
    });
  });

  return results;
}


/**
 * Extracts heading info from an array of object like those that are generated
 * by the Codex or EditorJS block content editors.
 */
function extractObjectSourceHeadings(source: TableOfContentsObjectSource[]) {
  const results: HeadingInfo[] = [];

  for (const entry of source) {
    const result: HeadingInfo = {
      level : NaN,
      text  : '',
      slug  : '',

      apply(update) {
        entry.id = this.slug; return update;
      },
    };

    if (entry.type === 'heading') {
      result.level = entry.data.level;
      result.text  = entry.data.content || '';
      result.slug  = result.text ? slugify(result.text) : nanoid(10);
    }
    else if (entry.type === 'header') {
      result.level = 'attrs' in entry ? entry.attrs.level : entry.data.level;
      result.text  = 'data' in entry ? entry.data.text : entry.content.map((item) => item.text).join('');
      result.slug  = result.text ? slugify(result.text) : nanoid(10);
    }

    if (result.level) {
      results.push(result);
    }
  }

  return results;
}


/**
 * Makes a header the "child" of the provided parent, such as when an H3 follows after an H2, or adds it to
 * an accumulator array for future processing (if we saw, in order, an H2 -> H3 -> H4 -> H3, then while most
 * organizing would be easy - the parent is simply the last encountered heading - the last H3 would need to
 * be made a child of the first H2 and so gets held).
 */
function adoptChild(child: TableOfContents, parent: TableOfContents | undefined, orphanage?: TableOfContents[]) {
  child.slug   = (parent ? parent.slug + '__' : '') + child.slug;
  child.parent = parent;

  parent?.children.push(child);

  if (!parent) {
    orphanage?.push(child);
  }
}
